package org.researchstack.backbone.result;

import androidx.annotation.NonNull;

import org.researchstack.backbone.answerformat.AnswerFormat;
import org.researchstack.backbone.step.QuestionStep;
import org.researchstack.backbone.step.Step;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * The StepResult class represents a result produced by a {@link org.researchstack.backbone.ui.step.layout.StepLayout}
 * to hold all child results of type <code>T</code> produced by the step.
 * <p>
 * A step result is typically generated by the framework as the task proceeds. When the task
 * completes, it may be appropriate to serialize it for transmission to a server, or to immediately
 * perform analysis on it.
 * <p>
 * For example, an {@link QuestionStep} object produces a result of type <code>T</code> that becomes
 * a child of the {@link StepResult} object.
 */
public class StepResult<T> extends Result implements Cloneable {
    /**
     * When StepResult only has a single value, pair that value with the following key
     */
    public static final String DEFAULT_KEY = "answer";

    private Map<String, T> results;

    private AnswerFormat answerFormat;

    /**
     * Creates a StepResult from a {@link Step}.
     * <p>
     * Using this constructor ensures that the StepResult has the correct identifier and answer
     * format for the corresponding step.
     *
     * @param step the step from which to create the StepResult
     */
    public StepResult(Step step) {
        super(step.getIdentifier());
        this.results = new HashMap<>();

        if (step instanceof QuestionStep) {
            answerFormat = ((QuestionStep) step).getAnswerFormat();
        }
        setStartDate(new Date());
        // this will be updated when the result is set
        setEndDate(new Date());
    }

    /**
     * Creates a StepResult from known step result, start and end dates.
     * <p>
     * Using this constructor ensures that the StepResult has the correct identifier and answer
     * format for the corresponding step.
     *
     * @param step the step used to create the StepResult
     * @param result step result value
     * @param startDate start date that was captured when the user started this step result
     * @param endDate end date that was captured the last time the user modified this step
     */
    public StepResult(Step step, T result, Date startDate, Date endDate) {
        super(step.getIdentifier());
        this.results = new HashMap<>();

        if (step instanceof QuestionStep) {
            answerFormat = ((QuestionStep) step).getAnswerFormat();
        }
        setStartDate(startDate);
        // this will be updated when the result is set
        setEndDate(endDate);
        setResultForIdentifier(DEFAULT_KEY, result);
    }

    public Map<String, T> getResults() {
        return results;
    }

    public void setResults(Map<String, T> results) {
        this.results = results;
    }

    /**
     * Returns the result stored using {@link #setResult}.
     *
     * @return the result with the default identifier
     */
    public T getResult() {
        return getResultForIdentifier(DEFAULT_KEY);
    }

    /**
     * Sets the result using the default key, useful when there is only a single result.
     *
     * @param result the result to save with the default key
     */
    public void setResult(T result) {
        setResultForIdentifier(DEFAULT_KEY, result);
        setEndDate(new Date());
    }

    /**
     * Returns the result for the given identifier, use this when there are multiple results for the
     * step.
     *
     * @param identifier the identifier used as the key for storing this result
     * @return the result for the given identifier
     */
    public T getResultForIdentifier(String identifier) {
        return results.get(identifier);
    }

    /**
     * Sets the result for the given identifier, use when there are multiple results for the step.
     * <p>
     * If there is only one result, use the {@link #setResult} convenience method instead.
     *
     * @param identifier the identifier for the result
     * @param result     the result to save
     */
    public void setResultForIdentifier(String identifier, T result) {
        results.put(identifier, result);
    }

    /**
     * Gets the {@link AnswerFormat} for this step result. May be useful when processing the
     * result.
     *
     * @return the answer format associated with the step
     */
    public AnswerFormat getAnswerFormat() {
        return answerFormat;
    }

    @Override
    public boolean equals(final Object other) {
        if (this == other) {
            return true;
        }
        if (other == null || getClass() != other.getClass()) {
            return false;
        }
        if (!super.equals(other)) {
            return false;
        }
        final StepResult<?> that = (StepResult<?>) other;
        return Objects.equals(getResults(), that.getResults()) &&
                Objects.equals(getAnswerFormat(), that.getAnswerFormat());
    }

    @Override
    public int hashCode() {
        return Objects.hash(super.hashCode(), getResults(), getAnswerFormat());
    }

    @NonNull
    @Override
    public Object clone() throws CloneNotSupportedException {
        StepResult cloned = (StepResult) super.clone();

        cloned.results = new HashMap<>();
        for (Map.Entry<String, T> e : results.entrySet()) {
            boolean isCloned = false;
            if (e.getValue() instanceof Cloneable) {
                try {
                    // This is going to clone any object of the type Cloneable, This is inevitable because we need to
                    // clone every answer in the results map in order to able to make changes to the original object
                    // without affecting the cloned one.
                    Method method = e.getValue().getClass().getDeclaredMethod("clone");
                    method.setAccessible(true);

                    cloned.results.put(e.getKey(), method.invoke(e.getValue()));
                    isCloned = true;
                } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException ex) {
                    ex.printStackTrace();
                }
            }
            if (!isCloned) {
                cloned.results.put(e.getKey(), e.getValue());
            }
        }

        cloned.answerFormat = answerFormat;
        cloned.setStartDate((Date) getStartDate().clone());
        // this will be updated when the result is set
        cloned.setEndDate((Date) getEndDate().clone());
        return cloned;
    }

    public Boolean allValuesAreNull() {
        int count = 0;
        for (Map.Entry<String, T> e : results.entrySet()) {
            final T value = e.getValue();
            final boolean isNull = value instanceof StepResult ?
                    ((StepResult) value).getResult() == null
                    : value == null;
            if (isNull) {
                count++;
            }
        }
        return results.size() == count;
    }
}
